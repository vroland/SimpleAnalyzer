<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Simple Analyzer: Utils-Namensbereichsreferenz</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Simple Analyzer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Erzeugt von Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Suchen');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Hauptseite</span></a></li>
      <li><a href="pages.html"><span>Zusätzliche&#160;Informationen</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namensbereiche</span></a></li>
      <li><a href="annotated.html"><span>Klassen</span></a></li>
      <li><a href="files.html"><span>Dateien</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Suchen" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Liste&#160;aller&#160;Namensbereiche</span></a></li>
      <li><a href="namespacemembers.html"><span>Elemente&#160;eines&#160;Namensbereiches</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Alle</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Klassen</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namensbereiche</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Dateien</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Funktionen</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variablen</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Aufzählungen</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Aufzählungswerte</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Freundbeziehungen</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Seiten</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Klassen</a> &#124;
<a href="#enum-members">Aufzählungen</a> &#124;
<a href="#func-members">Funktionen</a>  </div>
  <div class="headertitle">
<div class="title">Utils-Namensbereichsreferenz</div>  </div>
</div><!--header-->
<div class="contents">

<p>allgemeine Funktionen und Typen.  
<a href="#details">Mehr ...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Klassen</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtils_1_1Visualization__info.html">Visualization_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informationen über die Farbgebung bei der Visualisierung.  <a href="structUtils_1_1Visualization__info.html#details">Mehr ...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtils_1_1SortStruct.html">SortStruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hilfsstruktur zum Sortieren von Punkten nach dem Abstand zu einem anderen Punkt.  <a href="structUtils_1_1SortStruct.html#details">Mehr ...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtils_1_1SensorPoint.html">SensorPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Daten eines Sensordatenpunktes.  <a href="structUtils_1_1SensorPoint.html#details">Mehr ...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtils_1_1CutRender__info.html">CutRender_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Daten zur Darstellung einer 2D-Temperaturverteilungs-Ebene.  <a href="structUtils_1_1CutRender__info.html#details">Mehr ...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtils_1_1SensorData.html">SensorData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ein Sensordatensatz.  <a href="structUtils_1_1SensorData.html#details">Mehr ...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtils_1_1SensorPointComparator.html">SensorPointComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hilfsstruktur zum Vergleichen des Abstands von Messpunkten. Der Punkt, zu dem der Abstand berechnet werden soll ist in der Struktur gespeichert. Zum Vergleich zweier Messpunkte wird dann für beide der Abstand berechnet.  <a href="structUtils_1_1SensorPointComparator.html#details">Mehr ...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Aufzählungen</h2></td></tr>
<tr class="memitem:ad369b0127cabda0d6871ce1ae7e6c862"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#ad369b0127cabda0d6871ce1ae7e6c862">PIM_algorithm</a> { <b>ALGORITHM_TETRAHEDRONS</b> = 0, 
<b>ALGORITHM_RAY</b>
 }</td></tr>
<tr class="memdesc:ad369b0127cabda0d6871ce1ae7e6c862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zum Punkt-in-Volumen Testen verwendeter Algorithmus. Dies wird bei ALGORITHM_TETRAHEDRONS über alle Tetraeder des Objekts und deren Flächennormalen ermittelt. Bei ALGORITHM_RAY werden die Schnittpunkte aller Außenflächen mit einem Strahl gezählt (Aktuell nicht verwendet). <br/></td></tr>
<tr class="separator:ad369b0127cabda0d6871ce1ae7e6c862"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Funktionen</h2></td></tr>
<tr class="memitem:afac34330dde6235ee7395a4fd412ae0d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#afac34330dde6235ee7395a4fd412ae0d">sqr</a> (double d)</td></tr>
<tr class="separator:afac34330dde6235ee7395a4fd412ae0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb647325616858e0fad55290c36ea03b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#abb647325616858e0fad55290c36ea03b">clampHue</a> (float h)</td></tr>
<tr class="memdesc:abb647325616858e0fad55290c36ea03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begrenzt einen Wert auf den Bereich 0..1.  <a href="#abb647325616858e0fad55290c36ea03b">Mehr ...</a><br/></td></tr>
<tr class="separator:abb647325616858e0fad55290c36ea03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b506eef525971ab3ccb328f4ca879d"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#a76b506eef525971ab3ccb328f4ca879d">floattostr</a> (double val)</td></tr>
<tr class="separator:a76b506eef525971ab3ccb328f4ca879d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5711927eff2cdd7123d98d343f0dfad"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#ab5711927eff2cdd7123d98d343f0dfad">getTextBlock</a> (string data, int n)</td></tr>
<tr class="separator:ab5711927eff2cdd7123d98d343f0dfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233ff9a0b34b10195a434f1ff66323b8"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#a233ff9a0b34b10195a434f1ff66323b8">floattowxstr</a> (double val)</td></tr>
<tr class="separator:a233ff9a0b34b10195a434f1ff66323b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47160b3665d77f9e1a49a4045053add"><td class="memItemLeft" align="right" valign="top">wxString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#ac47160b3665d77f9e1a49a4045053add">floattowxstr</a> (double val, int digits)</td></tr>
<tr class="separator:ac47160b3665d77f9e1a49a4045053add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f216cc7011a901130db81321b565334"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#a5f216cc7011a901130db81321b565334">rayIntersectsTriangle</a> (<a class="el" href="classVector3D.html">Vector3D</a> *p, <a class="el" href="classVector3D.html">Vector3D</a> *direction, <a class="el" href="classTriangle.html">Triangle</a> *tri, double *depth)</td></tr>
<tr class="separator:a5f216cc7011a901130db81321b565334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fc5d6dab27f759ab5d76757a53023f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#af8fc5d6dab27f759ab5d76757a53023f">pointInsideMesh</a> (<a class="el" href="classVector3D.html">Vector3D</a> *p, <a class="el" href="classtetgenio.html">tetgenio</a> *io, <a class="el" href="namespaceUtils.html#ad369b0127cabda0d6871ce1ae7e6c862">PIM_algorithm</a> algorithm)</td></tr>
<tr class="separator:af8fc5d6dab27f759ab5d76757a53023f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b995a1220a78be108b19bda4b776332"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#a9b995a1220a78be108b19bda4b776332">pointInsideTetrahedron</a> (<a class="el" href="classVector3D.html">Vector3D</a> *pges, <a class="el" href="classVector3D.html">Vector3D</a> *v1, <a class="el" href="classVector3D.html">Vector3D</a> *v2, <a class="el" href="classVector3D.html">Vector3D</a> *v3, <a class="el" href="classVector3D.html">Vector3D</a> *v4)</td></tr>
<tr class="separator:a9b995a1220a78be108b19bda4b776332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7379e1915d2a04907eb9d99d0a56ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#a8f7379e1915d2a04907eb9d99d0a56ad">pointInsideTetrahedron</a> (double *pges, double *v1, double *v2, double *v3, double *v4)</td></tr>
<tr class="separator:a8f7379e1915d2a04907eb9d99d0a56ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40eaef4d22da849a5deb2f1153d88bbc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#a40eaef4d22da849a5deb2f1153d88bbc">pointInsideTetrahedron</a> (double *p, <a class="el" href="classstd_1_1vector.html">vector</a>&lt; <a class="el" href="structUtils_1_1SensorPoint.html">SensorPoint</a> * &gt; *tet)</td></tr>
<tr class="separator:a40eaef4d22da849a5deb2f1153d88bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ba26e928c7cef5269c51bfac49d547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#af4ba26e928c7cef5269c51bfac49d547">nextCombination</a> (<a class="el" href="classstd_1_1vector.html">vector</a>&lt; int &gt; *indices, int depth, int dataPointCount)</td></tr>
<tr class="separator:af4ba26e928c7cef5269c51bfac49d547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0ae18a42e2d206bc1b43da27820fe2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#a6a0ae18a42e2d206bc1b43da27820fe2">getPointValue</a> (int &amp;status, <a class="el" href="classstd_1_1vector.html">vector</a>&lt; <a class="el" href="structUtils_1_1SensorPoint.html">SensorPoint</a> &gt; *sensorpoints, double *p, <a class="el" href="classInterpolator.html">Interpolator</a> *interpolator, <a class="el" href="classstd_1_1vector.html">vector</a>&lt; <a class="el" href="structUtils_1_1SensorPoint.html">SensorPoint</a> * &gt; *prev_tet=NULL, <a class="el" href="classstd_1_1vector.html">vector</a>&lt; <a class="el" href="structUtils_1_1SensorPoint.html">SensorPoint</a> * &gt; *current_tet=NULL)</td></tr>
<tr class="separator:a6a0ae18a42e2d206bc1b43da27820fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6523eb946892eee52c9c74efd016de"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#a5d6523eb946892eee52c9c74efd016de">hsvToRgb</a> (float h, float s, float v)</td></tr>
<tr class="separator:a5d6523eb946892eee52c9c74efd016de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0438a85ca31977c95f5d27090d5346"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtils.html#adc0438a85ca31977c95f5d27090d5346">copySensorPoint</a> (<a class="el" href="structUtils_1_1SensorPoint.html">SensorPoint</a> *from, <a class="el" href="structUtils_1_1SensorPoint.html">SensorPoint</a> *to)</td></tr>
<tr class="separator:adc0438a85ca31977c95f5d27090d5346"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Ausführliche Beschreibung</h2>
<div class="textblock"><p>allgemeine Funktionen und Typen. </p>
</div><h2 class="groupheader">Dokumentation der Funktionen</h2>
<a class="anchor" id="abb647325616858e0fad55290c36ea03b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Utils::clampHue </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begrenzt einen Wert auf den Bereich 0..1. </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Die zu begrenzende Zahl. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Der den Grenzen entsprechende Wert. </dd></dl>

</div>
</div>
<a class="anchor" id="adc0438a85ca31977c95f5d27090d5346"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::copySensorPoint </td>
          <td>(</td>
          <td class="paramtype">SensorPoint *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SensorPoint *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Kopiert die Eigenschaften eines Sensorpunktes in einen Anderen. </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Quelle. </td></tr>
    <tr><td class="paramname">to</td><td>Ziel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76b506eef525971ab3ccb328f4ca879d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string Utils::floattostr </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Hilfsfunktion zur Umwandlung einer Zahl in einen String. </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Die umzuwandelnde Zahl. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Der resultierende String. </dd></dl>

</div>
</div>
<a class="anchor" id="a233ff9a0b34b10195a434f1ff66323b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxString Utils::floattowxstr </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wandelt eine Fließkommazahl in einen wxWidgets-String um. </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Die umzuwandelnde Zahl. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Der entstandene String. </dd></dl>

</div>
</div>
<a class="anchor" id="ac47160b3665d77f9e1a49a4045053add"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxString Utils::floattowxstr </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wandelt eine Fließkommazahl in einen wxWidgets-String um. </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Die umzuwandelnde Zahl. </td></tr>
    <tr><td class="paramname">digits</td><td>Anzahl der zu übernehmenden Stellen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Der entstandene String. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a0ae18a42e2d206bc1b43da27820fe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Utils::getPointValue </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstd_1_1vector.html">vector</a>&lt; SensorPoint &gt; *&#160;</td>
          <td class="paramname"><em>sensorpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classInterpolator.html">Interpolator</a> *&#160;</td>
          <td class="paramname"><em>interpolator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstd_1_1vector.html">vector</a>&lt; SensorPoint * &gt; *&#160;</td>
          <td class="paramname"><em>prev_tet</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstd_1_1vector.html">vector</a>&lt; SensorPoint * &gt; *&#160;</td>
          <td class="paramname"><em>current_tet</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gibt den inter/extrapolierten Wert eines Punktes zurück. </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Rückgabevariable. 1: Punkt wurde extrapoliert 0: Punkt wurde interpoliert. -1: Alle Sensorpunkte sind komplanar. </td></tr>
    <tr><td class="paramname">sensorpoints</td><td>Die zu verwendenden Senosorpunkte. </td></tr>
    <tr><td class="paramname">p</td><td>Die Koordinaten des gesuchten Punktes. </td></tr>
    <tr><td class="paramname">interpolator</td><td>Das zu verwendende Interpolatorobjekt. </td></tr>
    <tr><td class="paramname">prev_tet</td><td>Zuerst zu Testender Tetraeder (optional, NULL zum Nichtverwenden). </td></tr>
    <tr><td class="paramname">current_tet</td><td>Rückgabevariable für den zuletzt verwendeten Tetraeder (optional, NULL zum Nichtverwenden). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Temperatur des gesuchten Punktes. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5711927eff2cdd7123d98d343f0dfad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Utils::getTextBlock </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gibt den n-ten durch Leerzeichen oder Tabulator abgetrennten Block aus einem String zurück. </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Der Ausgansstring. </td></tr>
    <tr><td class="paramname">n</td><td>Index des zu findenden Blocks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Der n-te durch Leerzeichen getrennte Teilstring. "" Bei ungültigem Index. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d6523eb946892eee52c9c74efd016de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * Utils::hsvToRgb </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wandelt eine Farbe im HSV-Format ins RGB-Format um. Gefunden unter <a href="http://stackoverflow.com/questions/8208905/hsv-0-255-to-rgb-0-255">http://stackoverflow.com/questions/8208905/hsv-0-255-to-rgb-0-255</a>. (5.9.13) </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>H-Komponente der Farbe. </td></tr>
    <tr><td class="paramname">s</td><td>S-Komponente der Farbe. </td></tr>
    <tr><td class="paramname">v</td><td>V-Komponente der Farbe. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>RGB-Farbe als Liste mit 3 Werten im Bereich 0..1. Muss manuell mit delete[] freigegeben werden! </dd></dl>

</div>
</div>
<a class="anchor" id="af4ba26e928c7cef5269c51bfac49d547"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::nextCombination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstd_1_1vector.html">vector</a>&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dataPointCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ermöglicht das generieren aller möglichen Verteilungen von 4 Elementen auf dataPointCount Plätze. Die Indices der Plätze, die die Elemente jeweils besetzten stehen in indices. Verschiedene Reihenfolgen der selben Indices werden dabei nicht generiert. Diese Funktion generiert aus der vorherigen Anordnung die Nächste, indem die Indices bis zum überlauf hochgezählt wird, woraufhin der vorhergehende erhöht wird, z.b. für dataPointCount = 8:<br/>
 0 1 2 3<br/>
0 1 2 4<br/>
0 1 2 5<br/>
0 1 2 6<br/>
0 1 2 7<br/>
0 1 2 8 -&gt; Umschlag<br/>
0 1 3 4<br/>
0 1 3 5<br/>
0 1 3 6<br/>
 </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Liste der Indices der Elemente. </td></tr>
    <tr><td class="paramname">depth</td><td>Index des in diesem Funktionsaufruf verarbeiteten Elements. Beim ersten Aufruf also 3. </td></tr>
    <tr><td class="paramname">dataPointCount</td><td>Anzahl der Plätze. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8fc5d6dab27f759ab5d76757a53023f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utils::pointInsideMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector3D.html">Vector3D</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtetgenio.html">tetgenio</a> *&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PIM_algorithm&#160;</td>
          <td class="paramname"><em>algorithm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Testet, ob sich ein Punkt innerhalb eines Körpers befindet. </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Der zu testende Punkt. </td></tr>
    <tr><td class="paramname">io</td><td>Der zu testende Körper als Tetgen-Daten (s. Tetgen Dokumentation). </td></tr>
    <tr><td class="paramname">algorithm</td><td>Der zu verwendende Testalgorithmus (Empfohlen und ausschließlich verwendet: ALGORITHM_TETRAHEDRONS). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>1 Wenn innerhalb, 0 wenn außerhalb. Bei einer falschen Algorithmuskonstante -1. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b995a1220a78be108b19bda4b776332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utils::pointInsideTetrahedron </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector3D.html">Vector3D</a> *&#160;</td>
          <td class="paramname"><em>pges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector3D.html">Vector3D</a> *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector3D.html">Vector3D</a> *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector3D.html">Vector3D</a> *&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector3D.html">Vector3D</a> *&#160;</td>
          <td class="paramname"><em>v4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Testet, ob sich ein Punkt innerhalb eines Tetraeders befindet. </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">pges</td><td>Der zu testende Punkt. </td></tr>
    <tr><td class="paramname">v1</td><td>Der 1. Punkt des Tetraeders. </td></tr>
    <tr><td class="paramname">v2</td><td>Der 2. Punkt des Tetraeders. </td></tr>
    <tr><td class="paramname">v3</td><td>Der 3. Punkt des Tetraeders. </td></tr>
    <tr><td class="paramname">v4</td><td>Der 4. Punkt des Tetraeders. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>1 Wenn innerhalb, 0 wenn außerhalb. -1, wenn der Tetraeder komplanar ist. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f7379e1915d2a04907eb9d99d0a56ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utils::pointInsideTetrahedron </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Testet, ob sich ein Punkt innerhalb eines Tetraeders befindet. </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">pges</td><td>Koordinaten des zu testenden Punktes. </td></tr>
    <tr><td class="paramname">v1</td><td>Koordinaten des 1. Punktes des Tetraeders. </td></tr>
    <tr><td class="paramname">v2</td><td>Koordinaten des 2. Punktes des Tetraeders. </td></tr>
    <tr><td class="paramname">v3</td><td>Koordinaten des 3. Punktes des Tetraeders. </td></tr>
    <tr><td class="paramname">v4</td><td>Koordinaten des 4. Punktes des Tetraeders. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>1 Wenn innerhalb, 0 wenn außerhalb. -1, wenn der Tetraeder komplanar ist. </dd></dl>

</div>
</div>
<a class="anchor" id="a40eaef4d22da849a5deb2f1153d88bbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utils::pointInsideTetrahedron </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstd_1_1vector.html">vector</a>&lt; SensorPoint * &gt; *&#160;</td>
          <td class="paramname"><em>tet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Testet, ob sich ein Punkt innerhalb eines Tetraeders befindet. </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Koordinaten des zu testenden Punktes. </td></tr>
    <tr><td class="paramname">tet</td><td>Der zu untersuchende Tetraeder als Liste von Sensordaten. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>1 Wenn innerhalb, 0 wenn außerhalb. -1, wenn der Tetraeder komplanar ist. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f216cc7011a901130db81321b565334"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utils::rayIntersectsTriangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector3D.html">Vector3D</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector3D.html">Vector3D</a> *&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangle.html">Triangle</a> *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Testet, ob ein Strahl ein Dreieck schneidet. Gefunden unter <a href="http://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm">http://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm</a> am 4.9.13 und auf C++ und eigene Datentypen portiert. </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Ortsvektor zum Ausganspunkt des Strahls. </td></tr>
    <tr><td class="paramname">direction</td><td>Richtung des Strahls. </td></tr>
    <tr><td class="paramname">tri</td><td>Das zu testende Dreieck. </td></tr>
    <tr><td class="paramname">depth</td><td>Ausgabevariablie, ein Maß für den Abstand von Ausganspunkt zu Schnittpunkt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd>Gibt 1 zurück, wenn es einen Schnittpunkt gibt, ansonsten 0. </dd></dl>

</div>
</div>
<a class="anchor" id="afac34330dde6235ee7395a4fd412ae0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Utils::sqr </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quadriert eine Zahl. </p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Die zu quadrierende Zahl. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Rückgabe</dt><dd><img class="formulaInl" alt="$d^2$" src="form_6.png"/>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Erzeugt am Fre Aug 29 2014 16:35:48 für Simple Analyzer von &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
